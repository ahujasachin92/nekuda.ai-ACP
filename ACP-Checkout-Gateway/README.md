# ACP Checkout Gateway

<img width="1500" height="500" alt="image" src="https://github.com/user-attachments/assets/fcbbbe3e-0f9b-4e9e-8a3a-eab97786ca86" />
<br><br>
The Agentic Commerce Protocol (ACP) requires each merchant to host a gateway that receives specific calls from agents. This repository provides a reference implementation of that gateway - a drop-in HTTP service you can deploy in minutes. It exposes the required ACP endpoints for checkout sessions, validates requests, and returns an authoritative cart state on every response.
<br><br>
The server integrates with your existing order system and coordinates checkout requests from agents. It also emits order webhooks for state sync, enforces idempotency, verifies signatures, and handles auth, retries, and input validation.
<br><br>
Deploy via Terraform or AWS SAM on serverless primitives for low ops, then map the adapter interfaces to your order system. 
<br><br>
Enables a standards-compliant, production-grade ACP checkout gateway without building the integration from scratch.

## ‚öôÔ∏è Specification

This project implements a REST API conforming to the [ACP Agentic Checkout Specification](https://github.com/agentic-commerce-protocol/agentic-commerce-protocol/blob/main/rfcs/rfc.agentic_checkout.md).  
The server is built with Express.js and can run both locally for development and on AWS Lambda for production.

## üß© Key Features

- **Serverless Architecture** ‚Äì Auto-scaling Lambda functions with pay-per-use pricing  
- **Event Sourcing** ‚Äì Complete audit trail with append-only data storage  
- **Real-time Events** ‚Äì Instant notifications via DynamoDB Streams ‚Üí SNS ‚Üí SQS  
- **Comprehensive Testing** ‚Äì E2E tests with full pub/sub event validation  
- **Production Ready** ‚Äì Built-in security, error handling, and monitoring  
- **Cost Optimized** ‚Äì Serverless design minimizes operational costs

## üèóÔ∏è Architecture

The system follows an event-driven, serverless architecture that automatically scales and provides real-time event notifications.

### Generated Type Files

**‚ö†Ô∏è Do not manually edit these files - they are auto-generated:**

- **`src/api.ts`** - TypeScript types generated from the OpenAPI spec
- **`src/webhooks.ts`** - TypeScript types generated from the OpenAPI spec
- **`src/types.ts`** - TypeScript types generated from JSON schemas

These files are generated by running:
```bash
cd spec
./generate-types.sh
```

If you make changes to the OpenAPI spec or schemas, you must regenerate the types.

## Project Structure

```
src/
‚îú‚îÄ‚îÄ api.ts                    # Auto-generated OpenAPI types
‚îú‚îÄ‚îÄ types.ts                  # Auto-generated JSON schema types
‚îú‚îÄ‚îÄ server.ts                 # Express app configuration
‚îú‚îÄ‚îÄ local.ts                  # Local development server
‚îú‚îÄ‚îÄ lambda.ts                 # AWS Lambda handler
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îî‚îÄ‚îÄ checkoutController.ts # Business logic for checkout operations
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îî‚îÄ‚îÄ checkout.ts           # API route definitions
‚îî‚îÄ‚îÄ middleware/
    ‚îî‚îÄ‚îÄ errorHandler.ts       # Error handling middleware

spec/
‚îú‚îÄ‚îÄ openapi.agentic_checkout.yaml  # OpenAPI specification
‚îî‚îÄ‚îÄ generate-types.sh              # Script to generate TypeScript types
```


## üöÄ Quick Start

### 1. Deploy to AWS
```bash
# Clone the repository
git clone https://github.com/your-org/acp-checkout-manager.git
cd acp-checkout-manager

# Deploy with AWS SAM
cd infra
sam build && sam deploy --guided
```

### 2. Local Development
```bash
# Install dependencies
npm install

# Set required environment variables
export SESSION_HISTORY_TABLE="acp-checkout-manager-dev-sessions"
export IDEMPOTENCY_TABLE="acp-checkout-manager-dev-created-sessions"
export MERCHANT_TERMS_OF_USE_URL="http://localhost:3000/terms"
export MERCHANT_PRIVACY_POLICY_URL="http://localhost:3000/privacy"
export MERCHANT_SHOP_POLICIES_URL="http://localhost:3000/policies"

# Start development server
npm run dev
```

**Environment Variables for Local Development:**

| Variable | Description | Example |
|----------|-------------|---------|
| `SESSION_HISTORY_TABLE` | DynamoDB table name for session history | `acp-checkout-manager-dev-sessions` |
| `IDEMPOTENCY_TABLE` | DynamoDB table name for idempotency tracking | `acp-checkout-manager-dev-created-sessions` |
| `MERCHANT_TERMS_OF_USE_URL` | URL to your terms of service page | `http://localhost:3000/terms` |
| `MERCHANT_PRIVACY_POLICY_URL` | URL to your privacy policy page | `http://localhost:3000/privacy` |
| `MERCHANT_SHOP_POLICIES_URL` | URL to your shop policies (returns, shipping, etc.) | `http://localhost:3000/policies` |

**Note:** The local server connects to DynamoDB tables in your AWS account. Ensure you have AWS credentials configured (via `~/.aws/credentials` or environment variables) and the DynamoDB tables exist. You can create the tables by deploying the stack first, or use the table names from an existing deployment.

## üì° API Endpoints

The system provides a complete checkout API compatible with OpenAI's Agentic Commerce Protocol:

| Method | Endpoint | Description | Events Triggered |
|--------|----------|-------------|-----------------|
| `POST` | `/checkout_sessions` | Create a new session | `checkout.session.created` |
| `GET` | `/checkout_sessions/{id}` | Retrieve session details | - |
| `POST` | `/checkout_sessions/{id}` | Update session | `checkout.session.updated` |
| `POST` | `/checkout_sessions/{id}/complete` | Complete checkout | `checkout.session.completed` |
| `POST` | `/checkout_sessions/{id}/cancel` | Cancel session | `checkout.session.cancelled` |

### Example: Create a checkout session
```bash
curl -X POST https://your-api.execute-api.us-east-1.amazonaws.com/dev/checkout_sessions \
  -H "Content-Type: application/json" \
  -d '{
    "items": [
      {
        "id": "product_1",
        "quantity": 2
      }
    ]
  }'
```

**Response:**
```json
{
  "id": "cs_1234567890_abc123",
  "status": "ready_for_payment",
  "currency": "usd",
  "line_items": [
    {
      "id": "line_1234567890_def456",
      "item": {
        "id": "product_1",
        "quantity": 2
      },
      "base_amount": 3600,
      "discount": 360,
      "subtotal": 3240,
      "tax": 259,
      "total": 3499
    }
  ],
  "totals": [
    {
      "type": "items_base_amount",
      "display_text": "Items",
      "amount": 3600
    },
    {
      "type": "items_discount", 
      "display_text": "Bulk Discount",
      "amount": 360
    },
    {
      "type": "subtotal",
      "display_text": "Subtotal",
      "amount": 3240
    },
    {
      "type": "tax",
      "display_text": "Tax",
      "amount": 259
    },
    {
      "type": "total",
      "display_text": "Total",
      "amount": 3499
    }
  ],
  "fulfillment_options": [],
  "messages": [],
  "links": []
}
```

## üîå Merchant Integration

To connect this gateway to your existing e-commerce system, implement the `MerchantService` interface defined in `src/services/merchant.ts`. This interface has two core methods that bridge the ACP gateway with your inventory, pricing, and order management systems:

### Required Methods

#### 1. `getMerchantData(items: Item[], fulfillmentAddress: Address | undefined): MerchantData`

Called when a checkout session is created or updated. This method must:

- **Fetch real-time pricing** for the requested items from your inventory system
- **Calculate line items** including base amounts, discounts, taxes, and totals
- **Return fulfillment options** (shipping methods, delivery times, costs) based on the fulfillment address
- **Provide messages** to display to the user (promotions, warnings, informational text)

**Example:**
```typescript
getMerchantData(items: Item[], fulfillmentAddress: Address | undefined): MerchantData {
  // Query your inventory database
  const lineItems = items.map(item => {
    const product = this.inventory.getProduct(item.id);
    const price = product.price * item.quantity;
    const tax = this.calculateTax(price, fulfillmentAddress);

    return {
      id: `line_${item.id}`,
      item: { id: item.id, quantity: item.quantity },
      base_amount: price,
      discount: this.applyDiscounts(item),
      subtotal: price - discount,
      tax: tax,
      total: price - discount + tax
    };
  });

  // Fetch shipping options from your fulfillment system
  const fulfillmentOptions = this.shipping.getOptions(fulfillmentAddress);

  return { line_items: lineItems, fulfillment_options: fulfillmentOptions, messages: [] };
}
```

#### 2. `createOrder(session: CheckoutSession): Order`

Called when a checkout session is completed. This method must:

- **Create an order** in your order management system
- **Process payment** (or coordinate with your payment processor)
- **Return order details** including a unique order ID and a permalink URL where the customer can view their order
- **Trigger fulfillment** workflows in your system

**Example:**
```typescript
createOrder(session: CheckoutSession): Order {
  // Create order in your OMS
  const order = this.oms.createOrder({
    items: session.line_items,
    customer: session.contact,
    shipping_address: session.fulfillment_address,
    payment_method: session.payment
  });

  // Return order reference for webhook callbacks
  return {
    id: order.id,
    checkout_session_id: session.id,
    permalink_url: `https://yourstore.com/orders/${order.id}`
  };
}
```

### Implementation Steps

1. **Create your implementation** of `MerchantService` in `src/services/merchantData.ts`
2. **Replace the stub** in your controller with your implementation
3. **Deploy** your changes to AWS

See the `MerchantServiceStub` class in `src/services/merchant.ts` for a complete reference implementation with sample data.

### Configuration Options

The gateway is configured via CloudFormation parameters in `infra/template.yaml`. These parameters control merchant branding, webhook delivery, and system behavior:

#### Merchant Information
Parameters displayed in checkout sessions and sent to agents:

| Parameter | Description | Default |
|-----------|-------------|---------|
| `MerchantName` | Your merchant/brand name used in webhook signatures | `Merchant` |
| `MerchantTermsOfUseUrl` | URL to your terms of service | `http://merchant.example.com/terms_of_use` |
| `MerchantPrivacyPolicyUrl` | URL to your privacy policy | `http://merchant.example.com/privacy` |
| `MerchantShopPolicies` | URL to your shop policies (returns, shipping, etc.) | `http://merchant.example.com/policies` |

#### Agent Webhook Configuration
Configure where order events are sent for agent synchronization:

| Parameter | Description | Default |
|-----------|-------------|---------|
| `AgentWebhookUrl` | OpenAI webhook endpoint for order updates | `https://openai.example.com/agentic_checkout/webhooks/order_events` |
| `AgentWebhookSecretKey` | HMAC signing key for webhook authentication (NoEcho) | `secret_key_123` |

**Note:** The webhook follows the [OpenAPI specification](spec/openapi.agentic_checkout_webhook.yaml) and sends HMAC-signed payloads with order lifecycle events (`order_create`, `order_update`).

#### Deployment Configuration

| Parameter | Description | Default |
|-----------|-------------|---------|
| `Environment` | Deployment environment (dev, staging, prod) | `dev` |
| `StackName` | CloudFormation stack name prefix | `acp-checkout-manager` |

#### Deployment Example

```bash
cd infra
sam build && sam deploy \
  --parameter-overrides \
    Environment=prod \
    MerchantName="YourStore" \
    MerchantTermsOfUseUrl="https://yourstore.com/terms" \
    MerchantPrivacyPolicyUrl="https://yourstore.com/privacy" \
    MerchantShopPolicies="https://yourstore.com/policies" \
    AgentWebhookUrl="https://api.openai.com/agentic_checkout/webhooks/order_events" \
    AgentWebhookSecretKey="your-secure-hmac-key"
```

### Receiving Checkout Events

The gateway publishes all checkout session events to an SNS topic (`CheckoutEventsTopic`) defined in `infra/template.yaml`. You can subscribe to this topic to receive real-time notifications about checkout lifecycle events in your own systems.

**Common integration pattern:**
1. Create an SQS queue in your AWS account
2. Subscribe your queue to the `CheckoutEventsTopic` SNS topic
3. Process events from your queue to update inventory, send notifications, trigger analytics, etc.

**Event structure:**
```json
{
  "eventType": "created",
  "sessionId": "cs_1234567890_abc123",
  "version": 1,
  "status": "pending",
  "timestamp": "2025-10-09T14:27:09.951Z",
  "data": {
    "id": "cs_1234567890_abc123",
    "status": "pending",
    "line_items": [...],
    "totals": [...]
  }
}
```

**Event types** include: `created`, `updated`, `completed`, `canceled`

The SNS topic ARN is available in the CloudFormation outputs after deployment:
```bash
aws cloudformation describe-stacks --stack-name acp-checkout-manager-dev \
  --query "Stacks[0].Outputs[?OutputKey=='CheckoutEventsTopicArn'].OutputValue" \
  --output text
```

### Sending Order Updates to Agents

The gateway includes an SQS queue (`OrderUpdatesQueue`) that automatically sends webhook notifications to agents (like OpenAI's ChatGPT) when orders are updated. When you publish messages to this queue, the system triggers the `OrderNotificationsFunction` Lambda, which sends HMAC-signed webhooks to the configured agent endpoint.

**How it works:**
1. Your order management system publishes order events to the `OrderUpdatesQueue`
2. The Lambda function is automatically triggered by new messages
3. Webhooks are sent to the agent endpoint (configured via `AgentWebhookUrl`)
4. Events are signed with HMAC for security (using `AgentWebhookSecretKey`)

**Message format:**
Messages must follow the [webhook specification](spec/openapi.agentic_checkout_webhook.yaml):

```json
{
  "type": "order_create",
  "data": {
    "type": "order",
    "checkout_session_id": "cs_1234567890_abc123",
    "permalink_url": "https://yourstore.com/orders/ord_xyz789",
    "status": "created",
    "refunds": []
  }
}
```

**Event types:**
- `order_create` - New order placed
- `order_update` - Order status changed (shipped, fulfilled, canceled, etc.)

**Status values:** `created`, `manual_review`, `confirmed`, `canceled`, `shipped`, `fulfilled`

**Publishing events:**
```bash
# Using AWS CLI
aws sqs send-message \
  --queue-url $(aws cloudformation describe-stacks --stack-name acp-checkout-manager-dev \
    --query "Stacks[0].Outputs[?OutputKey=='OrderUpdatesQueueUrl'].OutputValue" --output text) \
  --message-body '{"type":"order_update","data":{"type":"order","checkout_session_id":"cs_123","permalink_url":"https://yourstore.com/orders/456","status":"shipped","refunds":[]}}'
```

**Using AWS SDK:**
```typescript
import { SQSClient, SendMessageCommand } from '@aws-sdk/client-sqs';

const sqs = new SQSClient({});
await sqs.send(new SendMessageCommand({
  QueueUrl: process.env.ORDER_UPDATES_QUEUE_URL,
  MessageBody: JSON.stringify({
    type: 'order_update',
    data: {
      type: 'order',
      checkout_session_id: session.id,
      permalink_url: `https://yourstore.com/orders/${order.id}`,
      status: 'shipped',
      refunds: []
    }
  })
}));
```

The queue includes automatic retry logic with a dead-letter queue (DLQ) for failed webhook deliveries, ensuring reliable notification delivery to agents.

## üß™ Comprehensive Testing

The system includes advanced E2E testing with **pub/sub event validation** - a unique feature that tests the complete event-driven architecture:

```bash
# Test API endpoints only  
./test/e2e-test.sh https://your-api.com/dev

# Test complete architecture (API + Events)
./test/e2e-test.sh https://your-api.com/dev \
  https://sqs.region.amazonaws.com/account/queue-name \
  aws-profile-name

# Node.js version with response times
node test/e2e-test.js --url https://your-api.com/dev \
  --sqs https://sqs.region.amazonaws.com/account/queue \
  --profile aws-profile
```

### Testing Coverage
- **9 API Test Scenarios** - All checkout operations and error cases
- **5 Event Validation Tests** - DynamoDB ‚Üí Streams ‚Üí SNS ‚Üí SQS flow  
- **Complete Architecture** - End-to-end validation of the entire system

## Performance & Scalability

- **Auto-scaling** - Lambda functions scale automatically with demand
- **Cost-effective** - Pay only for actual usage (requests + compute time)
- **High availability** - Built on AWS managed services with 99.99% uptime SLA
- **Global deployment** - Deploy to any AWS region for low latency
- **Event sourcing** - Complete audit trail with version history

## üìÅ Project Structure

```
‚îú‚îÄ‚îÄ src/                   # Main application code
‚îÇ   ‚îú‚îÄ‚îÄ controllers/       # Business logic
‚îÇ   ‚îú‚îÄ‚îÄ routes/            # API route definitions  
‚îÇ   ‚îî‚îÄ‚îÄ lambda.ts          # AWS Lambda handler
‚îú‚îÄ‚îÄ infra/                 # AWS SAM infrastructure
‚îÇ   ‚îú‚îÄ‚îÄ src/               # Event processing functions
‚îÇ   ‚îî‚îÄ‚îÄ template.yaml      # CloudFormation template
‚îú‚îÄ‚îÄ test/                  # E2E testing with pub/sub validation
‚îú‚îÄ‚îÄ spec/                  # OpenAPI specification
‚îî‚îÄ‚îÄ docs/                  # Additional documentation
```

## üìö Documentation

| Area                   | Resource                                                                 |
| ----------------------- | ------------------------------------------------------------------------ |
| Merchant Integration    | [docs/merchant-integration.md](docs/merchant-integration.md) - Complete integration examples with SQS/SNS webhooks |
| Architecture Details    | [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md) - Deep dive into the technical design |
| Deployment Guide        | [docs/DEPLOYMENT.md](docs/DEPLOYMENT.md) - Step-by-step deployment instructions |
| Infrastructure README   | [infra/README.md](infra/README.md) - AWS SAM deployment details |
| Testing Guide           | [test/README.md](test/README.md) - Comprehensive testing documentation |

### ü§ù Collaboration
If you're interested in collaborating or contributing, get in touch at **[founder@nekuda.ai](mailto:founder@nekuda.ai)**.

## ‚ö†Ô∏è Known Limitations

The current ACP specification does not define certain security mechanisms, which affects this implementation:

- **Request Signature Verification:** The specification does not define how request payload signatures should be calculated. As a result, this implementation does not validate request signatures when ensuring idempotent responses.

- **API Key Authentication:** The specification does not define an API key authentication mechanism. This implementation currently operates without API key-based authentication for incoming requests.

These features will be added once the ACP specification defines the appropriate standards for request signing and authentication mechanisms.

## üìú License

Licensed under the Apache 2.0 License.
